//
//  Player.h
//  Demo
//
//  This class represents a player in a grid-based game.
//
//  Notes:
//  - Position is stored in world coordinates (pixels) for smooth rendering
//  - Grid position is managed by the game scene/controller
//  - Movement is step-based: start → animate → complete
//  - PlayerId is generated by a static counter for local creation
//  - No physics - collision checking happens at the gameplay level
//
#ifndef __PLAYER_H__
#define __PLAYER_H__
#include <cugl/cugl.h>
#include "Direction.h"

/**
 * Class representing a player in a grid-based game.
 *
 * The player moves in discrete steps on a grid. Each step is animated
 * smoothly from one grid cell to another over a fixed duration.
 */
class Player {
#pragma mark -
#pragma mark States
    
public:

#pragma mark -
#pragma mark Attributes
private:
    /** Current rendered position (world/pixels) */
    cugl::Vec2 _pos;
    
    /** Start position of current movement step */
    cugl::Vec2 _start;
    
    /** Target position for current movement step */
    cugl::Vec2 _target;
    
    /** Unique identifier for this player */
    int _ID;
    
    /** Static counter for generating player IDs */
    static int _playerID;

    /** Whether player is currently moving between cells */
    bool _moving;
    
    /** Whether player is carrying an object */
    bool _isCarrying;

    /** the id of the thing being carried*/
    int _carried_id = -1;
    
    /** Time elapsed in current movement step (seconds) */
    float _moveTime;
    
    /** Total duration for one movement step (seconds) */
    float _moveDuration;
    
    /** Current facing direction */
    Direction _facing;
    
    float _scale;
    
    float _radius;
    float _width;
    float _height;
    
    
    /** The texture for rendering this player */
    std::shared_ptr<cugl::graphics::Texture> _texture;
    std::shared_ptr<cugl::graphics::Texture> _carry;
    
    /** The scene graph node for rendering */
    std::shared_ptr<cugl::scene2::PolygonNode> _node;

public:
#pragma mark -
#pragma mark Constructors

    /**
     * Creates a player at the given world position.
     *
     * @param pos Initial world position (center of sprite)
     */
    Player(const cugl::Vec2& pos);

    /**
     * Destroys the player, releasing all resources.
     */
    ~Player() { dispose(); }
    
    /**
     * Disposes all resources allocated to this player.
     */
    void dispose();
    
    /**
     * Initializes the player with a texture.
     *
     * @param pos     Initial world position
     * @param texture The texture for rendering
     *
     * @return true if initialization was successful
     */
    bool init(const cugl::Vec2& pos, const std::shared_ptr<cugl::graphics::Texture>& texture);
    
    /**
     * Returns a newly allocated player.
     *
     * @param pos     Initial world position
     * @param texture The texture for rendering
     *
     * @return a newly allocated player
     */
    static std::shared_ptr<Player> alloc(const cugl::Vec2& pos,
                                         const std::shared_ptr<cugl::graphics::Texture>& texture) {
        std::shared_ptr<Player> result = std::make_shared<Player>(pos);
        return (result->init(pos, texture) ? result : nullptr);
    }

#pragma mark -
#pragma mark Position

    /**
     * Returns the current rendered position in world coordinates.
     *
     * @return the current rendered position
     */
    const cugl::Vec2& getPosition() const { return _pos; }

    /**
     * Hard-sets the position (cancels any ongoing movement).
     *
     * @param value The new position in world coordinates
     */
    void setPosition(const cugl::Vec2& value);
    
#pragma mark -
#pragma mark Identification
    
    /**
     * Returns the unique player ID.
     *
     * @return the unique player ID
     */
    int getPlayerID() const { return _ID; }
    
#pragma mark -
#pragma mark Carrying State
    
    /**
     * Returns true if the player is currently carrying an object.
     *
     * @return true if carrying an object
     */
    bool isCarrying() const { return _isCarrying; }
    
    /**
     * Sets whether the player is carrying an object.
     *
     * @param carrying Whether the player is carrying
     */
    void setCarrying(bool carrying, int carrier_id) { _isCarrying = carrying; _carried_id = carrier_id;}
    /** 
    * Gets the id of the carried obj, returns -1 if non carried
    */
    int getCarried() {
        return _carried_id;
    }

#pragma mark -
#pragma mark Movement

    /**
     * Returns true if currently animating a movement step.
     *
     * @return true if currently moving
     */
    bool isMoving() const { return _moving; }

    /**
     * Returns the current facing direction.
     *
     * @return the current facing direction
     */
    Direction getFacing() const { return _facing; }
    
    /**
     * Sets the facing direction without moving.
     *
     * @param dir The new facing direction
     */
    void setFacing(Direction dir) { _facing = dir; }

    /**
     * Sets how long one movement step takes (seconds).
     *
     * @param duration The duration in seconds for one step
     */
    void setMoveDuration(float duration) { _moveDuration = duration; }
    
    /**
     * Returns the movement duration.
     *
     * @return the movement duration in seconds
     */
    float getMoveDuration() const { return _moveDuration; }

    /**
     * Starts a single movement step in the given direction.
     *
     * The caller should perform collision checks before calling this.
     * This begins smooth animation from current position to target.
     *
     * @param dir   Direction of movement
     * @param delta World-space displacement for one step (e.g., cell size)
     */
    void startStep(Direction dir, const cugl::Vec2& delta);

    /**
     * Updates smooth movement animation. Call once per frame.
     *
     * Interpolates position from _start to _target over _moveDuration.
     *
     * @param dt Delta time in seconds
     */
    void update(float dt);
    void move(Direction dir, float gridSize, int nRow, int nCol);
    
#pragma mark -
#pragma mark Rendering
    
    /**
     * Returns the scene graph node for this player.
     *
     * @return the scene graph node
     */
    std::shared_ptr<cugl::scene2::PolygonNode> getNode() const { return _node; }
    
    /**
     * Draws this player to the sprite batch.
     *
     * @param batch The sprite batch for drawing
     */
    void draw(const std::shared_ptr<cugl::graphics::SpriteBatch>& batch);
    
#pragma mark Graphics
    /**
     * Returns the sprite sheet for the ship
     *
     * The size and layout of the sprite sheet should already be specified in
     * the initializing JSON. Otherwise, the contents of the sprite sheet will
     * be ignored.
     *
     * @return the sprite sheet for the ship
     */
    const std::shared_ptr<cugl::graphics::Texture>& getTexture() const {
        return _texture;
    }
    /**
     * Sets the texture for this ship.
     *
     * The texture should be formated as a sprite sheet, and the size and
     * layout of the sprite sheet should already be specified in the
     * initializing JSON. If so, this method will construct a sprite sheet
     * from this texture. Otherwise, the texture will be ignored.
     *
     * @param texture   The texture for the sprite sheet
     */
    void setTexture(const std::shared_ptr<cugl::graphics::Texture>& texture);
    void setCarry(const std::shared_ptr<cugl::graphics::Texture>& texture);
    float getScale(){ return _scale;}
};


#endif /* __PLAYER_H__ */

